{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport '../../vendor/polyfills/Function/prototype/bind';\nimport '../../vendor/polyfills/Event'; // addEventListener\nimport '../../vendor/polyfills/Element/prototype/closest';\nfunction ErrorSummary($module) {\n  this.$module = $module;\n}\nErrorSummary.prototype.init = function () {\n  var $module = this.$module;\n  if (!$module) {\n    return;\n  }\n  $module.focus();\n  $module.addEventListener('click', this.handleClick.bind(this));\n};\n\n/**\n* Click event handler\n*\n* @param {MouseEvent} event - Click event\n*/\nErrorSummary.prototype.handleClick = function (event) {\n  var target = event.target;\n  if (this.focusTarget(target)) {\n    event.preventDefault();\n  }\n};\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA (as tested in 2018.3.2) - without this only the field type is announced\n * (e.g. \"Edit, has autocomplete\").\n *\n * @param {HTMLElement} $target - Event target\n * @returns {boolean} True if the target was able to be focussed\n */\nErrorSummary.prototype.focusTarget = function ($target) {\n  // If the element that was clicked was not a link, return early\n  if ($target.tagName !== 'A' || $target.href === false) {\n    return false;\n  }\n  var inputId = this.getFragmentFromUrl($target.href);\n  var $input = document.getElementById(inputId);\n  if (!$input) {\n    return false;\n  }\n  var $legendOrLabel = this.getAssociatedLegendOrLabel($input);\n  if (!$legendOrLabel) {\n    return false;\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  $legendOrLabel.scrollIntoView();\n  $input.focus({\n    preventScroll: true\n  });\n  return true;\n};\n\n/**\n * Get fragment from URL\n *\n * Extract the fragment (everything after the hash) from a URL, but not including\n * the hash.\n *\n * @param {string} url - URL\n * @returns {string} Fragment from URL, without the hash\n */\nErrorSummary.prototype.getFragmentFromUrl = function (url) {\n  if (url.indexOf('#') === -1) {\n    return false;\n  }\n  return url.split('#').pop();\n};\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor\n * - The first `<label>` that is associated with the input using for=\"inputId\"\n * - The closest parent `<label>`\n *\n * @param {HTMLElement} $input - The input\n * @returns {HTMLElement} Associated legend or label, or null if no associated\n *                        legend or label can be found\n */\nErrorSummary.prototype.getAssociatedLegendOrLabel = function ($input) {\n  var $fieldset = $input.closest('fieldset');\n  if ($fieldset) {\n    var legends = $fieldset.getElementsByTagName('legend');\n    if (legends.length) {\n      return legends[0];\n    }\n  }\n  return document.querySelector(\"label[for='\" + $input.getAttribute('id') + \"']\") || $input.closest('label');\n};\nexport default ErrorSummary;","map":{"version":3,"names":["ErrorSummary","$module","prototype","init","focus","addEventListener","handleClick","bind","event","target","focusTarget","preventDefault","$target","tagName","href","inputId","getFragmentFromUrl","$input","document","getElementById","$legendOrLabel","getAssociatedLegendOrLabel","scrollIntoView","preventScroll","url","indexOf","split","pop","$fieldset","closest","legends","getElementsByTagName","length","querySelector","getAttribute"],"sources":["/Users/Maksym/Documents/GitHub/trebisov/frontend/node_modules/@id-sk/frontend/govuk/components/error-summary/error-summary.js"],"sourcesContent":["import '../../vendor/polyfills/Function/prototype/bind'\nimport '../../vendor/polyfills/Event' // addEventListener\nimport '../../vendor/polyfills/Element/prototype/closest'\n\nfunction ErrorSummary ($module) {\n  this.$module = $module\n}\n\nErrorSummary.prototype.init = function () {\n  var $module = this.$module\n  if (!$module) {\n    return\n  }\n  $module.focus()\n\n  $module.addEventListener('click', this.handleClick.bind(this))\n}\n\n/**\n* Click event handler\n*\n* @param {MouseEvent} event - Click event\n*/\nErrorSummary.prototype.handleClick = function (event) {\n  var target = event.target\n  if (this.focusTarget(target)) {\n    event.preventDefault()\n  }\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA (as tested in 2018.3.2) - without this only the field type is announced\n * (e.g. \"Edit, has autocomplete\").\n *\n * @param {HTMLElement} $target - Event target\n * @returns {boolean} True if the target was able to be focussed\n */\nErrorSummary.prototype.focusTarget = function ($target) {\n  // If the element that was clicked was not a link, return early\n  if ($target.tagName !== 'A' || $target.href === false) {\n    return false\n  }\n\n  var inputId = this.getFragmentFromUrl($target.href)\n  var $input = document.getElementById(inputId)\n  if (!$input) {\n    return false\n  }\n\n  var $legendOrLabel = this.getAssociatedLegendOrLabel($input)\n  if (!$legendOrLabel) {\n    return false\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  $legendOrLabel.scrollIntoView()\n  $input.focus({ preventScroll: true })\n\n  return true\n}\n\n/**\n * Get fragment from URL\n *\n * Extract the fragment (everything after the hash) from a URL, but not including\n * the hash.\n *\n * @param {string} url - URL\n * @returns {string} Fragment from URL, without the hash\n */\nErrorSummary.prototype.getFragmentFromUrl = function (url) {\n  if (url.indexOf('#') === -1) {\n    return false\n  }\n\n  return url.split('#').pop()\n}\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor\n * - The first `<label>` that is associated with the input using for=\"inputId\"\n * - The closest parent `<label>`\n *\n * @param {HTMLElement} $input - The input\n * @returns {HTMLElement} Associated legend or label, or null if no associated\n *                        legend or label can be found\n */\nErrorSummary.prototype.getAssociatedLegendOrLabel = function ($input) {\n  var $fieldset = $input.closest('fieldset')\n\n  if ($fieldset) {\n    var legends = $fieldset.getElementsByTagName('legend')\n\n    if (legends.length) {\n      return legends[0]\n    }\n  }\n\n  return document.querySelector(\"label[for='\" + $input.getAttribute('id') + \"']\") ||\n    $input.closest('label')\n}\n\nexport default ErrorSummary\n"],"mappings":";;AAAA,OAAO,gDAAgD;AACvD,OAAO,8BAA8B,EAAC;AACtC,OAAO,kDAAkD;AAEzD,SAASA,YAAY,CAAEC,OAAO,EAAE;EAC9B,IAAI,CAACA,OAAO,GAAGA,OAAO;AACxB;AAEAD,YAAY,CAACE,SAAS,CAACC,IAAI,GAAG,YAAY;EACxC,IAAIF,OAAO,GAAG,IAAI,CAACA,OAAO;EAC1B,IAAI,CAACA,OAAO,EAAE;IACZ;EACF;EACAA,OAAO,CAACG,KAAK,EAAE;EAEfH,OAAO,CAACI,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACC,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAP,YAAY,CAACE,SAAS,CAACI,WAAW,GAAG,UAAUE,KAAK,EAAE;EACpD,IAAIC,MAAM,GAAGD,KAAK,CAACC,MAAM;EACzB,IAAI,IAAI,CAACC,WAAW,CAACD,MAAM,CAAC,EAAE;IAC5BD,KAAK,CAACG,cAAc,EAAE;EACxB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,YAAY,CAACE,SAAS,CAACQ,WAAW,GAAG,UAAUE,OAAO,EAAE;EACtD;EACA,IAAIA,OAAO,CAACC,OAAO,KAAK,GAAG,IAAID,OAAO,CAACE,IAAI,KAAK,KAAK,EAAE;IACrD,OAAO,KAAK;EACd;EAEA,IAAIC,OAAO,GAAG,IAAI,CAACC,kBAAkB,CAACJ,OAAO,CAACE,IAAI,CAAC;EACnD,IAAIG,MAAM,GAAGC,QAAQ,CAACC,cAAc,CAACJ,OAAO,CAAC;EAC7C,IAAI,CAACE,MAAM,EAAE;IACX,OAAO,KAAK;EACd;EAEA,IAAIG,cAAc,GAAG,IAAI,CAACC,0BAA0B,CAACJ,MAAM,CAAC;EAC5D,IAAI,CAACG,cAAc,EAAE;IACnB,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACAA,cAAc,CAACE,cAAc,EAAE;EAC/BL,MAAM,CAACb,KAAK,CAAC;IAAEmB,aAAa,EAAE;EAAK,CAAC,CAAC;EAErC,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,YAAY,CAACE,SAAS,CAACc,kBAAkB,GAAG,UAAUQ,GAAG,EAAE;EACzD,IAAIA,GAAG,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IAC3B,OAAO,KAAK;EACd;EAEA,OAAOD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3B,YAAY,CAACE,SAAS,CAACmB,0BAA0B,GAAG,UAAUJ,MAAM,EAAE;EACpE,IAAIW,SAAS,GAAGX,MAAM,CAACY,OAAO,CAAC,UAAU,CAAC;EAE1C,IAAID,SAAS,EAAE;IACb,IAAIE,OAAO,GAAGF,SAAS,CAACG,oBAAoB,CAAC,QAAQ,CAAC;IAEtD,IAAID,OAAO,CAACE,MAAM,EAAE;MAClB,OAAOF,OAAO,CAAC,CAAC,CAAC;IACnB;EACF;EAEA,OAAOZ,QAAQ,CAACe,aAAa,CAAC,aAAa,GAAGhB,MAAM,CAACiB,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAC7EjB,MAAM,CAACY,OAAO,CAAC,OAAO,CAAC;AAC3B,CAAC;AAED,eAAe7B,YAAY"},"metadata":{},"sourceType":"module"}